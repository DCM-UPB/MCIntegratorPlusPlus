#ifndef MCINTEGRATOR
#define MCINTEGRATOR

#include <vector>
#include <random>
#include <fstream>
#include <string>

// Function that MCI uses for the sampled pdf
typedef void (*MCISamFun)(const int &, const double *, double &);
//                        ^ndim       ^walker position   ^output

// Function that MCI uses for the observables
typedef void (*MCIObsFun)(const int &, const double *, const int &, double *);
//                        ^ndim       ^walker position  ^dim of outputs ^output

// Function that MCI uses for the proto-sampling function
typedef void (*MCIProtoSamFun)(const int &, const double *, const int &, double *);
//                              ^ndim       ^walker position ^dim of outputs ^output

// Acceptance function, given the new and old values of the (ficticious) sampling function
typedef void (*MCIAccFun)(const int &, const double *, const double *, double &);
//                        ^num of proto sampling function values  
//                                     ^old values     ^new values     ^output


class MCI
{
   protected:
      const double INITIAL_STEP=0.1;

      std::random_device _rdev;
      std::mt19937_64 _rgen;
      std::uniform_real_distribution<double> _rd;  //after initialization (done in the constructor) can be used with _rd(_rgen)

      int _ndim;  // number of dimensions
      double ** _irange;  // integration ranges
      double _vol;  // Integration volume

      double * _x;  // walker position
      double * _propx;  //walker propsed position
      double * _mrt2step;  // M(RT)^2 random step

      double _targetaccrate;  // accepted and rejected moves
      int _acc, _rej;  // the MC integration will be done sampling from this pdf

      MCISamFun _pdf;  // Sampled probability density function (pdf)
      bool _flagpdf;  // did the user provide a pdf?

      MCIAccFun _accfun;  // If it is used, then the sampling function is a ficticious one, used as an input for this function
      bool _flagaccfun;  // is there a special acceptance function?
      std::vector<MCIProtoSamFun> _protosamp;  // Vector of proto-sampling functions
      std::vector<int> _protosampdim; // Vector of proto-sampling functions's output dimensions
      int _nprotosamp;  // number of proto-sampling functions
      int _nprotosampdim;  // total number of dimensions required by the proto-sampling functions
      
      double * _pdfx;  // value of the pdf function in x (both for the pdf or the proto-sampling functions)
      double * _proppdfx;  // value of the pdf function in x

      std::vector<MCIObsFun> _obs;  // Vector of observable functions
      std::vector<int> _obsdim;  // Vector of observable functions's output dimensions
      double * _obsx;  // array of values of the obs function in x
      int _nobs;  // number of observables
      int _nobsdim; // total number of dimensions required by the observables

      int _ridx;  // running index, which keeps track of the index of datax
      double ** _datax;  // array that will contain all the measured observable
      bool _flagMC; //flag that is true only when MCI is accumulating data for the integral

      std::ofstream _obsfile;  //ofstream for storing obs values while sampling
      std::string _pathobsfile;
      int _freqobsfile;
      bool _flagobsfile;  // should write an output file with sampled obs values?
      
      std::ofstream _wlkfile;  //ofstream for storing obs values while sampling
      std::string _pathwlkfile;
      int _freqwlkfile;
      bool _flagwlkfile;  // should write an output file with sampled obs values?


      // --- Internal methods
      void confirmOldObservables();
      void computeNewObservables();
      void computeSamplingFunction();
      void computeProposedSamplingFunction();
      void computeProposedPosition();

      void resetAccRejCounters();

      void newX();
      void applyPBC(double * v);
      void doStepMRT2(bool * flagacc);
      void findMRT2Step();

      void sample(const long &npoints, const bool &flagobs);
      void initialDecorrelation();

      void storeObservables();
      void storeWalkerPositions();


   public:
      MCI(const int & ndim);  //Constructor, need the number of dimensions
      ~MCI();  //Destructor

      // --- Setters
      void setIRange(const double * const * irange);

      void setX(const double * x);
      void setMRT2Step(const double * mrt2step);

      void setTargetAcceptanceRate(const double * targetaccrate);

      void setSamplingFunction(MCISamFun pdf);
      void noSamplingFunction();

      void setProtoSamplingFunction(MCIProtoSamFun pdf, const int &psfdim);
      void clearProtoSamplingFunctions();
      void setAcceptanceFunction(MCIAccFun accfun);
      void noAcceptanceFunction();

      void setObservable(MCIObsFun obs, const int &obsdim);
      void clearObservables();

      void storeObservablesOnFile(const char * filepath, const int &freq);
      void storeWalkerPositionsOnFile(const char * filepath, const int &freq);

      // --- Getters
      int getNDim(){return _ndim;}
      double getIRange(const int &i, const int &j){return *(*(_irange+i)+j);}
      double getX(const int &i){return *(_x+i);}
      double getMRT2Step(const int &i){return *(_mrt2step+i);}
      double getTargetAcceptanceRate(){return _targetaccrate;}
      MCISamFun getSamplingFunction(){return _pdf;}
      MCIObsFun getObservable(const int &i){return _obs[i];}
      MCIAccFun getAcceptanceFunction(){return _accfun;}

      double getAcceptanceRate(){return (double(_acc)/(double(_acc+_rej)));}

      // --- Integrate
      void integrate(const long &Nmc, double * average, double * error);


};

#endif
